1.MySQL常用存储引擎
  1.InnoDB是MySQL的默认存储引擎，支持事务、表锁\行锁和外键等操作,数据和索引是集中存储的
  2.MyISAM是MySQL 5.1版本前的默认存储引擎，MyISAM的并发性比较差，不支持事务和外键等操作，默认的锁粒度为表级锁,数据和索引是分开存储的

2.三大范式
第一范式：确保每列保持原子性，数据表中的所有字段值都是不可分解的原子值
第二范式：确保表中的每列都和主键相关
第三范式：确保每列都和主键列直接相关而不是间接相关

3.MySQL数据类型
1.整数
2.浮点数
3.字符串
4.日期

4、 索引
什么是索引
索引是一种用于快速查询和检索数据的数据结构 ，常见的索引结构有: B 树， B+树和 Hash。

索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。

索引的优缺点？
优点：

大大加快数据检索的速度。
将随机I/O变成顺序I/O(因为B+树的叶子节点是连接在一起的)
加速表与表之间的连接
缺点：

从空间角度考虑，建立索引需要占用物理空间

从时间角度 考虑，创建和维护索引都需要花费时间，例如对数据进行增删改的时候都需要维护 索引

索引的数据结构？
索引的数据结构主要有B+树和哈希表，对应的索引分别为B+树索引和哈希索引。InnoDB引擎的索引类 型有B+树索引和哈希索引，默认的索引类型为B+树索引。

B+树索引

熟悉数据结构的同学都知道，B+树、平衡二叉树、红黑树都是经典的数据结构。在B+树中，所有 的记录节点都是按照键值大小的顺序放在叶子节点上，如下图。



从上图可以看出 ，因为B+树具有有序性，并且所有的数据都存放在叶子节点，所以查找的效率非 常高，并且支持排序和范围查找。

B+树的索引又可以分为主索引和辅助索引。其中主索引为聚簇索引，辅助索引为非聚簇索引。聚簇 索引是以主键作为B+ 树索引的键值所构成的B+树索引，聚簇索引的叶子节点存储着完整的数据记 录；非聚簇索引是以非主键的列作为B+树索引的键值所构成的B+树索引，非聚簇索引的叶子节点 存储着主键值。所以使用非聚簇索引进行查询时，会先找到主键值，然后到根据聚簇索引找到主键 对应的数据域。上图中叶子节点存储的是数据记录，为聚簇索引的结构图，非聚簇索引的结构图如 下：



上图中的字母为数据的非主键的列值，假设要查询该列值为B的信息，则需先找到主键7，在到聚簇 索引中查询主键7所对应的数据域。

哈希索引

哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。

为何能够通过 key 快速取出 value呢？ 原因在于 哈希算法（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。

hash = hashfunc(key)
index = hash % array_size
1
2


但是！哈希算法有个 Hash 冲突 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 链地址法。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 HashMap 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后HashMap为了减少链表过长的时候搜索时间过长引入了红黑树。



为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。

既然哈希表这么快，为什么MySQL 没有使用其作为索引的数据结构呢？

1.Hash 冲突问题 ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。

2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点： 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。

Hash索引和B+树的区别？
因为两者数据结构上的差异导致它们的使用场景也不同，哈希索引一般多用于精确的等值查找，B+索引 则多用于除了精确的等值查找外的其他查找。在大多数情况下，会选择使用B+树索引。

哈希索引不支持排序，因为哈希表是无序的。

哈希索引不支持范围查找。

哈希索引不支持模糊查询及多列索引的最左前缀匹配。

因为哈希表中会存在哈希冲突，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定 的，每次查询都是从根节点到叶子节点

索引的种类有哪些？
主键索引：数据列不允许重复，不能为NULL，一个表只能有一个主键索引
组合索引：由多个列值组成的索引。
唯一索引：数据列不允许重复，可以为NULL，索引列的值必须唯一的，如果是组合索引，则列值 的组合必须唯一。
全文索引：对文本的内容进行搜索。
普通索引：基本的索引类型，可以为NULL
B树和B+树的区别？
B树和B+树最主要的区别主要有两点：

B树中的内部节点和叶子节点均存放键和值，而B+树的内部节点只有键没有值，叶子节点存放所有 的键和值。
B＋树的叶子节点是通过相连在一起的，方便顺序检索。
两者的结构图如下。

请添加图片描述

数据库为什么使用B+树而不是B树？
B树适用于随机检索，而B+树适用于随机检索和顺序检索
B+树的空间利用率更高，因为B树每个节点要存储键和值，而B+树的内部节点只存储键，这样B+树 的一个节点就可以存储更多的索引，从而使树的高度变低，减少了I/O次数，使得数据检索速度更 快。
B+树的叶子节点都是连接在一起的，所以范围查找，顺序查找更加方便
B+树的性能更加稳定，因为在B+树中，每次查询都是从根节点到叶子节点，而在B树中，要查询的 值可能不在叶子节点，在内部节点就已经找到。
那在什么情况适合使用B树呢，因为B树的内部节点也可以存储值，所以可以把一些频繁访问的值放在距 离根节点比较近的地方，这样就可以提高查询效率。综上所述，B+树的性能更加适合作为数据库的索引 。

什么是聚簇索引，什么是非聚簇索引？
聚簇索引和非聚簇索引最主要的区别是数据和索引是否分开存储。

聚簇索引：将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。
非聚簇索引：将数据进和索引分开存储，索引叶子节点存储的是指向数据行的地址 。
在InnoDB存储引擎中，默认的索引为B+树索引，**利用主键创建的索引为主索引，也是聚簇索引，在主 索引之上创建的索引为辅助索引，也是非聚簇索引。**为什么说辅助索引是在主索引之上创建的呢，因为 辅助索引中的叶子节点存储的是主键。

在MyISAM存储引擎中，默认的索引也是B+树索引，但主索引和辅助索引都是非聚簇索引，也就是说索 引结构的叶子节点存储的都是一个指向数据行的地址。并且使用辅助索引检索无需访问主键的索引。





非聚簇索引一定会进行回表查询吗？
上面是说了非聚簇索引的叶子节点存储的是主键，也就是说要先通过非聚簇索引找到主键，再通过聚簇索引找到主键所对应的数据，后面这个再通过聚簇索引找到主键对应的数据的过程就是回表查询，那么非聚簇索引就一定会进行回表查询吗？

答案是不一定的。

试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。

SELECT name FROM user WHERE name='xiaoli';
1
那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。

即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果 SQL 查的就是主键呢?

SELECT id FROM table WHERE id=1;
1
主键索引本身的 key 就是主键，查到返回就行了。 这种情况就称之为覆盖索引了。

所以通过索引覆盖能解决非聚簇索引回表查询的问题。

索引的使用场景有哪些？
对于中大型表建立索引非常有效，对于非常小的表，一般全部表扫描速度更快些。
对于超大型的表，建立和维护索引的代价也会变高，这时可以考虑分区技术。
如何表的增删改非常多，而查询需求非常少的话，那就没有必要建立索引了，因为维护索引也是需要代价的。
一般不会出现再where条件中的字段就没有必要建立索引了。
多个字段经常被查询的话可以考虑联合索引。
字段多且字段值没有重复的时候考虑唯一索引。
字段多且有重复的时候考虑普通索引。
索引的设计原则？
最适合索引的列是在where后面出现的列或者连接句子中指定的列，而不是出现在SELECT关键字后 面的选择列表中的列。
索引列的基数越大，索引的效果越好，换句话说就是索引列的区分度越高，索引的效果越好。比如 使用性别这种区分度很低的列作为索引，效果就会很差，因为列的基数最多也就是三种，大多不是 男性就是女性。
尽量使用短索引，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉 及到的磁盘I/O较少，并且索引高速缓存中的块可以容纳更多的键值，会使得查询速度更快。
尽量利用最左前缀。
不要过度索引，每个索引都需要额外的物理空间，维护也需要花费时间，所以索引不是越多越好。
如何对索引进行优化？
对索引的优化其实最关键的就是要符合索引的设计原则和应用场景，将不符合要求的索引优化成符合索 引设计原则和应用场景的索引。

除了索引的设计原则和应用场景那几点外，还可以从以下两方面考虑。

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，因为这样无法使用索引。例 如 select * from table_name where a + 1 = 2
将区分度最高的索引放在前面
尽量少使用select *
如何创建/删除索引？
创建索引：

使用CREATE INDEX 语句
CREATE INDEX index_name ON table_name (column_list);
1
在CREATE TABLE时创建
 CREATE TABLE user(
 id INT PRIMARY KEY,
 information text,
 FULLTEXT KEY (information)
);
1
2
3
4
5
使用ALTER TABLE创建索引
ALTER TABLE table_name ADD INDEX index_name (column_list);
1
删除索引：

删除主键索引
alter table 表名 drop primary key 
1
删除其他索引
alter table 表名 drop key 索引名 
1
使用索引查询时性能一定会提升吗？
不一定，前面在索引的使用场景和索引的设计原则中已经提到了如何合理地使用索引，因为创建和维护 索引需要花费空间和时间上的代价，如果不合理地使用索引反而会使查询性能下降。

什么是前缀索引？
前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。

使用场景：前缀的区分度比较高的情况下。

建立前缀索引的方式

ALTER TABLE table_name ADD KEY(column_name(prefix_length));
1
这里面有个prefix_length参数很难确定，这个参数就是前缀长度的意思。通常可以使用以下方法进行确 定，先计算全列的区分度

SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;
1
然后在计算前缀长度为多少时和全列的区分度最相似。

SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) / COUNT(*) FROM table_name; 
1
不断地调整prefix_length的值，直到和全列计算出区分度相近。

什么是最左匹配原则？
最左匹配原则：从最左边为起点开始连续匹配，遇到范围查询（<、>、between、like）会停止匹配。

例如建立索引(a,b,c)，大家可以猜测以下几种情况是否用到了索引。

第一种
select * from table_name where a = 1 and b = 2 and c = 3
select * from table_name where b = 2 and a = 1 and c = 3
1
2
上面两次查询过程中所有值都用到了索引，where后面字段调换不会影响查询结果，因为MySQL中 的优化器会自动优化查询顺序。

第二种
select * from table_name where a = 1
select * from table_name where a = 1 and b = 2  
select * from table_name where a = 1 and b = 2 and c = 3
1
2
3
答案是三个查询语句都用到了索引，因为三个语句都是从最左开始匹配的。

第三种
select * from table_name where b = 1
select * from table_name where b = 1 and c = 2
1
2
答案是这两个查询语句都没有用到索引，因为不是从最左边开始匹配的

第四种
select * from table_name where a = 1 and c = 2
1
这个查询语句只有a列用到了索引，c列没有用到索引，因为中间跳过了b列，不是从最左开始连续 匹配的。

第五种
select * from table_name where a = 1 and b < 3 and c < 1
1
这个查询中只有a列和b列使用到了索引，而c列没有使用索引，因为根据最左匹配查询原则，遇到 范围查询会停止。

第六种
select * from table_name where a like 'ab%'; 
select * from table_name where a like '%ab'
select * from table_name where a like '%ab%'
1
2
3
对于列为字符串的情况，只有前缀匹配可以使用索引，中缀匹配和后缀匹配只能进行全表扫描。

索引在什么情况下会失效？
在上面介绍了几种不符合最左匹配原则的情况会导致索引失效，除此之外，以下这几种情况也会导致索 引失效。

条件中有or，例如 select * from table_name where a = 1 or b = 3
在索引上进行计算会导致索引失效，例如 select * from table_name where a + 1 = 2
在索引的类型上进行数据类型的隐形转换，会导致索引失效，例如字符串一定要加引号，假设 select * from table_name where a = ‘1’ 会使用到索引，如果写成 select * from table_name where a = 1 则会导致索引失效。
在索引中使用函数会导致索引失效，例如 select * from table_name where abs(a) = 1
在使用like查询时以%开头会导致索引失效
索引上使用!=、<>进行判断时会导致索引失效，例如 select * from table_name where a != 1
索引字段上使用 is null/is not null判断时会导致索引失效，例如 select * from table_name where a is null
5、事务
什么是事务？
简而言之， 事务是逻辑上的一组操作，要么都执行，要么都不执行。

事务的四大特性（ACID）是什么？
原子性：原子性是指包含事务的操作要么全部执行成功，要么全部失败回滚。
一致性：一致性指事务在执行前后状态是一致的。
隔离性：一个事务所进行的修改在最终提交之前，对其他事务是不可见的。
持久性：数据一旦提交，其所作的修改将永久地保存到数据库中。
数据事务的实现原理？
我们这里以 MySQL 的 InnoDB 引擎为例来简单说一下。

MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。

MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。

保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

数据库的并发一致性问题
当多个事务并发执行时，可能会出现以下问题：

脏读：事务A更新了数据，但还没有提交，这时事务B读取到事务A更新后的数据，然后事务A回滚 了，事务B读取到的数据就成为脏数据了。
不可重复读：事务A对数据进行多次读取，事务B在事务A多次读取的过程中执行了更新操作并提交 了，导致事务A多次读取到的数据并不一致。
幻读：事务A在读取数据后，事务B向事务A读取的数据中插入了几条数据，事务A再次读取数据时 发现多了几条数据，和之前读取的数据不一致。
丢失修改：事务A和事务B都对同一个数据进行修改，事务A先修改，事务B随后修改，事务B的修改 覆盖了事务A的修改。
不可重复度和幻读看起来比较像，它们主要的区别是：在不可重复读中，发现数据不一致主要是数据被 更新了。在幻读中，发现数据不一致主要是数据增多或者减少了。

数据库的隔离级别有哪些？
READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。


MySQL的默认隔离级别是可重复读。

隔离级别是如何实现的？
事务的隔离机制主要是依靠锁机制和MVCC(多版本并发控制)实现的，提交读和可重复读可以通过MVCC 实现，串行化可以通过锁机制实现。

什么是MVCC？
MVCC(multiple version concurrent control)是一种控制并发的方法，主要用来提高数据库的并发性 能。

在了解MVCC时应该先了解当前读和快照读。

当前读：读取的是数据库的最新版本，并且在读取时要保证其他事务不会修该当前记录，所以会对 读取的记录加锁。
快照读：不加锁读取操作即为快照读，使用MVCC来读取快照中的数据，避免加锁带来的性能损耗。
可以看到MVCC的作用就是在不加锁的情况下，解决数据库读写冲突问题，并且解决脏读、幻读、不可重复读等问题，但是不能解决丢失修改问题。

MVCC的实现原理？
版本号

系统版本号：是一个自增的ID，每开启一个事务，系统版本号都会递增。

事务版本号：事务版本号就是事务开始时的系统版本号，可以通过事务版本号的大小判断事务的时 间顺序。

行记录隐藏的列

在内部，InnoDB 存储引擎为每行数据添加了三个隐藏字段。

DB_ROW_ID：所需空间6byte，隐含的自增ID，用来生成聚簇索引，如果数据表没有指定聚簇索 引，InnoDB会利用这个隐藏ID创建聚簇索引。

DB_TRX_ID：所需空间6byte，最近修改的事务ID，记录创建这条记录或最后一次修改这条记录的 事务ID。

DB_ROLL_PTR：所需空间7byte，回滚指针，指向这条记录的上一个版本。

它们大致长这样，省略了具体字段的值。·



undo日志

MVCC做使用到的快照会存储在Undo日志中，该日志通过回滚指针将一个一个数据行的所有快照 连接起来。它们大致长这样。


举一个简单的例子说明下，比如最开始的某条记录长这样



现在来了一个事务对他的名字字段进行了修改，变成了这样



现在又来了一个事务2对它的名字进行了二次修改，它又变成了这样



从上面的分析可以看出，事务对同一记录的修改，记录的各个会在Undo日志中连接成一个线性表，在表 头的就是最新的旧纪录。 在重复读的隔离级别下，InnoDB的工作流程：

SELECT
作为查询的结果要满足两个条件：

当前事务所要查询的数据行快照的创建版本号必须小于当前事务的版本号，这样做的目的是保 证当前事务读取的数据行的快照要么是在当前事务开始前就已经存在的，要么就是当前事务自 身插入或者修改过的。
当前事务所要读取的数据行快照的删除版本号必须是大于当前事务的版本号，如果是小于等于 的话，表示该数据行快照已经被删除，不能读取。
INSERT

将当前系统版本号作为数据行快照的创建版本号。

DELETE

将当前系统版本号作为数据行快照的删除版本号。

UPDATE

保存当前系统版本号为更新前的数据行快照创建行版本号，并保存当前系统版本号为更新后的数据 行快照的删除版本号，其实就是，先删除在插入即为更新。

总结一下，MVCC的作用就是在避免加锁的情况下最大限度解决读写并发冲突的问题，它可以实现提交读和可重复度两个隔离级。

事务日志
innodb 事务日志包括 redo log（ 重做日志 ） 和 undo log（回滚日志）。

undo log 指事务开始之前，在操作任何数据之前，首先将需操作的数据备份到一个地方。

redo log 指事务中操作的任何数据，将最新的数据备份到一个地方。

事务日志的目的：实例或者介质失败，事务日志文件就能派上用场。

redo log

redo log 不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo 中。具体的落盘策略可以进行配置 。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。RedoLog 是为了实现事务的持久性而出现的产物。



undo log

undo log 用来回滚行记录到某个版本。事务未提交之前，Undo 保存了未提交之前的版本数据，Undo 中的数据可作为数据旧版本快照供其他并发事务进行快照读。是为了实现事务的原子性而出现的产物,在 MySQL innodb 存储引擎中用来实现多版本并发控制。



什么是MySQL的binlog
MySQL的 binlog 是记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。binlog 不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看 MySQL 执行过的所有语句。

MySQL binlog 以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。binlog 的主要目的是复制和恢复。

binlog 有三种格式，各有优缺点：

statement： 基于 SQL 语句的模式，某些语句和函数如 UUID, LOAD DATA INFILE 等在复制过程可能导致数据不一致甚至出错。
row： 基于行的模式，记录的是行的变化，很安全。但是 binlog 会比其他两种模式大很多，在一些大表中清除大量数据时在 binlog 中会生成很多条语句，可能导致从库延迟变大。
mixed： 混合模式，根据语句来选用是 statement 还是 row 模式。
数据库的锁
什么是数据库的锁？
当数据库有并发事务的时候，保证数据访问顺序的机制称为锁机制。

数据库的锁与隔离级别的关系？


数据库锁的类型有哪些？
按照锁的粒度可以将MySQL锁分为三种：



MyISAM默认采用表级锁，InnoDB默认采用行级锁。

从锁的类别上区别可以分为共享锁和排他锁

共享锁：共享锁又称读锁，简写为S锁，一个事务对一个数据对象加了S锁，可以对这个数据对象进行读取操作，但不能进行更新操作。并且在加锁期间其他事务只能对这个数据对象加S锁，不能加X 锁。
排他锁：排他锁又称为写锁，简写为X锁，一个事务对一个数据对象加了X锁，可以对这个对象进行读取和更新操作，加锁期间，其他事务不能对该数据对象进行加X锁或S锁。
它们的兼容情况如下



MySQL中InnoDB引擎的行锁模式及其是如何实现的？
行锁模式

在存在行锁和表锁的情况下，一个事务想对某个表加X锁时，需要先检查是否有其他事务对这个表加了锁或对这个表的某一行加了锁，对表的每一行都进行检测一次这是非常低效率的，为了解决这种问题，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁，两种意向锁都是表锁。

意向共享锁：简称IS锁，一个事务打算给数据行加共享锁前必须先获得该表的IS锁。

意向排他锁：简称IX锁，一个事务打算给数据行加排他锁前必须先获得该表的IX锁。

有了意向锁，一个事务想对某个表加X锁，只需要检查是否有其他事务对这个表加了X/IX/S/IS锁即可。

锁的兼容性如下 :



行锁实现方式：InnoDB的行锁是通过给索引上的索引项加锁实现的，如果没有索引，InnoDB将通过隐 藏的聚簇索引来对记录进行加锁。

InnoDB行锁主要分三种情况：

Record lock：对索引项加锁
Grap lock：对索引之间的“间隙”、第一条记录前的“间隙”或最后一条后的间隙加锁。
Next-key lock：前两种放入组合，对记录及前面的间隙加锁。
InnoDB行锁的特性：如果不通过索引条件检索数据，那么InnoDB将对表中所有记录加锁，实际产生的 效果和表锁是一样的。

MVCC不能解决幻读问题，在可重复读隔离级别下，使用MVCC+Next-Key Locks可以解决幻读问题。

什么是数据库的乐观锁和悲观锁，如何实现？
乐观锁：系统假设数据的更新在大多数时候是不会产生冲突的，所以数据库只在更新操作提交的时候对 数据检测冲突，如果存在冲突，则数据更新失败。

乐观锁实现方式：一般通过版本号和CAS算法实现。

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。通俗讲就是每次去拿数据的时候 都认为别人会修改，所以每次在拿数据的时候都会上锁。

悲观锁的实现方式：通过数据库的锁机制实现，对查询语句添加for update。

什么是死锁？如何避免？
死锁是指两个或者两个以上进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现 象。在MySQL中,MyISAM是一次获得所需的全部锁，要么全部满足，要么等待，所以不会出现死锁。 在InnoDB存储引擎中，除了单个SQL组成的事务外，锁都是逐步获得的，所以存在死锁问题。

如何避免MySQL发生死锁或锁冲突：

如果不同的程序并发存取多个表，尽量以相同的顺序访问表。
在程序以批量方式处理数据的时候，如果已经对数据排序，尽量保证每个线程按照固定的顺序来处 理记录。
在事务中，如果需要更新记录，应直接申请足够级别的排他锁，而不应该先申请共享锁，更新时在 申请排他锁，因为在当前用户申请排他锁时，其他事务可能已经获得了相同记录的共享锁，从而造 成锁冲突或者死锁。
尽量使用较低的隔离级别
尽量使用索引访问数据，使加锁更加准确，从而减少锁冲突的机会
合理选择事务的大小，小事务发生锁冲突的概率更低
尽量用相等的条件访问数据，可以避免Next-Key锁对并发插入的影响。
不要申请超过实际需要的锁级别，查询时尽量不要显示加锁
对于一些特定的事务，可以表锁来提高处理速度或减少死锁的概率。
SQL语句基础知识
SQL约束有哪些？
主键约束：主键为在表中存在一列或者多列的组合，能唯一标识表中的每一行。一个表只有一个主 键，并且主键约束的列不能为空。
外键约束：外键约束是指用于在两个表之间建立关系，需要指定引用主表的哪一列。只有主表的主 键可以被从表用作外键，被约束的从表的列可以不是主键，所以创建外键约束需要先定义主表的主 键，然后定义从表的外键。
唯一约束：确保表中的一列数据没有相同的值，一个表可以定义多个唯一约束。
默认约束：在插入新数据时，如果该行没有指定数据，系统将默认值赋给该行，如果没有设置没默 认值，则为NULL。
Check约束：Check会通过逻辑表达式来判断数据的有效性，用来限制输入一列或者多列的值的范 围。在列更新数据时，输入的内容必须满足Check约束的条件。
了解MySQL的几种连接查询吗？
MySQL的连接查询主要可以分为外连接，内连接，交叉连接

外连接
外连接主要分为左外连接(LEFT JOIN)、右外连接(RIGHT JOIN)、全外连接。

左外连接：显示左表中所有的数据及右表中符合条件的数据，右表中不符合条件的数据为null。


右外连接：显示左表中所有的数据及右表中符合条件的数据，右表中不符合条件的数据为null。



​ MySQL中不支持全外连接。

内连接：只显示符合条件的数据


交叉连接：使用笛卡尔积的一种连接。

两个集合X和Y的笛卡尔积表示为X × Y，第一个对象是X的成员而第二 个对象是Y的所有可能有序对的其中一个成员 。例如：A={a,b}，B={0,1,2}，A × B = {(a,0)，(a,1)， (a,2)，(b,0)，(b,1)，(b,2)}

举例如下：有两张表分为L表和R表。



左外连接 ： select L.*,R.* from L left join R on L.b=R.b


右外连接： select L.*,R.* from L right join R on L.b=R.b



交叉连接： select L.*,R.* from L,R

mysql中in和exists的区别？
in和exists一般用于子查询。

使用exists时会先进行外表查询，将查询到的每行数据带入到内表查询中看是否满足条件；使用in 一般会先进行内表查询获取结果集，然后对外表查询匹配结果集，返回数据。
in在内表查询或者外表查询过程中都会用到索引。
exists仅在内表查询时会用到索引
一般来说，当子查询的结果集比较大，外表较小使用exist效率更高；当子查询寻得结果集较小，外 表较大时，使用in效率更高。
对于not in和not exists，not exists效率比not in的效率高，与子查询的结果集无关，因为not in对 于内外表都进行了全表扫描，没有使用到索引。not exists的子查询中可以用到表上的索引。
varchar和char的区别？
varchar表示变长，char表示长度固定。当所插入的字符超过他们的长度时，在严格模式下，会拒 绝插入并提示错误信息，在一般模式下，会截取后插入。如char(5)，无论插入的字符长度是多少， 长度都是5，插入字符长度小于5，则用空格补充。对于varchar(5)，如果插入的字符长度小于5， 则存储的字符长度就是插入字符的长度，不会填充。
存储容量不同，对于char来说，最多能存放的字符个数为255。对于varchar，最多能存放的字符个 数是65532。
存储速度不同，char长度固定，存储速度会比varchar快一些，但在空间上会占用额外的空间，属 于一种空间换时间的策略。而varchar空间利用率会高些，但存储速度慢，属于一种时间换空间的 策略。
MySQL中int(10)和char(10)和varchar(10)的区别？
int(10)中的10表示的是显示数据的长度，而char(10)和varchar(10)表示的是存储数据的大小。

drop、delete和truncate的区别？


一般来讲，删除整个表，使用drop，删除表的部分数据使用delete，保留表结构删除表的全部数据使用 truncate。

UNION和UNION ALL的区别？
union和union all的作用都是将两个结果集合并到一起。

union会对结果去重并排序，union all直接直接返回合并后的结果，不去重也不进行排序。
union all的性能比union性能好。
大表数据查询如何进行优化？
索引优化
SQL语句优化
水平拆分
垂直拆分
建立中间表
使用缓存技术
固定长度的表访问起来更快
越小的列访问越快
了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？
慢查询一般用于记录执行时间超过某个临界值的SQL语句的日志。

相关参数：

slow_query_log：是否开启慢日志查询，1表示开启，0表示关闭。
slow_query_log_file：MySQL数据库慢查询日志存储路径。
long_query_time：慢查询阈值，当SQL语句查询时间大于阈值，会被记录在日志上。
log_queries_not_using_indexes：未使用索引的查询会被记录到慢查询日志中。
log_output：日志存储方式。“FILE”表示将日志存入文件。“TABLE”表示将日志存入数据库。
如何对慢查询进行优化？

分析语句的执行计划，查看SQL语句的索引是否命中
优化数据库的结构，将字段很多的表分解成多个表，或者考虑建立中间表。
优化LIMIT分页。
主键一般用自增ID还是UUID？
使用自增ID的好处：

字段长度较uuid会小很多。
数据库自动编号，按顺序存放，利于检索
无需担心主键重复问题
使用自增ID的缺点：

因为是自增，在某些业务场景下，容易被其他人查到业务量。
发生数据迁移时，或者表合并时会非常麻烦
在高并发的场景下，竞争自增锁会降低数据库的吞吐能力
UUID：通用唯一标识码，UUID是基于当前时间、计数器和硬件标识等数据计算生成的。

使用UUID的优点：

唯一标识，不会考虑重复问题，在数据拆分、合并时也能达到全局的唯一性。
可以在应用层生成，提高数据库的吞吐能力。
无需担心业务量泄露的问题。
使用UUID的缺点：

因为UUID是随机生成的，所以会发生随机IO，影响插入速度，并且会造成硬盘的使用率较低。
UUID占用空间较大，建立的索引越多，造成的影响越大。
UUID之间比较大小较自增ID慢不少，影响查询速度。
最后说下结论，一般情况MySQL推荐使用自增ID。因为在MySQL的InnoDB存储引擎中，主键索引是一 种聚簇索引，主键索引的B+树的叶子节点按照顺序存储了主键值及数据，如果主键索引是自增ID，只需 要按顺序往后排列即可，如果是UUID，ID是随机生成的，在数据插入时会造成大量的数据移动，产生大 量的内存碎片，造成插入性能的下降。

字段为什么要设置成not null?
首先说一点，NULL和空值是不一样的，空值是不占用空间的，而NULL是占用空间的，所以字段设为 NOT NULL后仍然可以插入空值。

字段设置成not null主要有以下几点原因：

NULL值会影响一些函数的统计，如count，遇到NULL值，这条记录不会统计在内。

B树不存储NULL，所以索引用不到NULL，会造成第一点中说的统计不到的问题。

NOT IN子查询在有NULL值的情况下返回的结果都是空值。

例如user表如下


select * from `user` where username NOT IN (select username from `user` where id != 0) 
1
这条查询语句应该查到zhangsan这条数据，但是结果显示为null。

MySQL在进行比较的时候，NULL会参与字段的比较，因为NULL是一种比较特殊的数据类型，数据 库在处理时需要进行特数处理，增加了数据库处理记录的复杂性。
如何优化查询过程中的数据访问？
从减少数据访问方面考虑：

正确使用索引，尽量做到索引覆盖
优化SQL执行计划
从返回更少的数据方面考虑：

数据分页处理
只返回需要的字段
从减少服务器CPU开销方面考虑：

合理使用排序
减少比较的操作
复杂运算在客户端处理
从增加资源方面考虑：

客户端多进程并行访问
数据库并行处理
如何优化长难的查询语句？
将一个大的查询分解为多个小的查询
分解关联查询，使缓存的效率更高
如何优化LIMIT分页？
在LIMIT偏移量较大的时候，查询效率会变低，可以记录每次取出的最大ID，下次查询时可以利用 ID进行查询
建立复合索引
如何优化WHERE子句
不要在where子句中使用!=和<>进行不等于判断，这样会导致放弃索引进行全表扫描。
不要在where子句中使用null或空值判断，尽量设置字段为not null。
尽量使用union all代替or
在where和order by涉及的列建立索引
尽量减少使用in或者not in，会进行全表扫描
在where子句中使用参数会导致全表扫描
避免在where子句中对字段及进行表达式或者函数操作会导致存储引擎放弃索引进而全表扫描
SQL语句执行的很慢原因是什么？
如果SQL语句只是偶尔执行很慢，可能是执行的时候遇到了锁，也可能是redo log日志写满了，要 将redo log中的数据同步到磁盘中去。
如果SQL语句一直都很慢，可能是字段上没有索引或者字段有索引但是没用上索引。
数据库优化
大表如何优化？
限定数据的范围：避免不带任何限制数据范围条件的查询语句。
读写分离：主库负责写，从库负责读。
垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。
水平分表：在同一个数据库内，把一个表的数据按照一定规则拆分到多个表中。
对单表进行优化：对表中的字段、索引、查询SQL进行优化。
添加缓存
为什么要分库分表？
分表

比如你单表都几千万数据了，你确定你能扛住么？绝对不行，单表数据量太大，会极大影响你的 sql执行的性能，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。

分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。

分库

分库就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。

这就是所谓的分库分表。

什么是垂直分表、垂直分库、水平分表、水平分库？
垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。一般会将常用的字段放到一个 表中，将不常用的字段放到另一个表中。

垂直分表的优势：

避免IO竞争减少锁表的概率。因为大的字段效率更低，第一数据量大，需要的读取时间长。第二， 大字段占用的空间更大，单页内存储的行数变少，会使得IO操作增多。 可
以更好地提升热门数据的查询效率。
垂直分库：按照业务对表进行分类，部署到不同的数据库上面，不同的数据库可以放到不同的服务器上 面。

垂直分库的优势：

降低业务中的耦合，方便对不同的业务进行分级管理。
可以提升IO、数据库连接数、解决单机硬件资源的瓶颈问题。
垂直拆分（分库、分表）的缺点：

主键出现冗余，需要管理冗余列
事务的处理变得复杂
仍然存在单表数据量过大的问题
水平分表：在同一个数据库内，把同一个表的数据按照一定规则拆分到多个表中。

水平分表的优势：

解决了单表数据量过大的问题
避免IO竞争并减少锁表的概率
水平分库：把同一个表的数据按照一定规则拆分到不同的数据库中，不同的数据库可以放到不同的服务 器上。
水平分库的优势：

解决了单库大数据量的瓶颈问题
IO冲突减少，锁的竞争减少，某个数据库出现问题不影响其他数据库（可用性），提高了系统的稳 定性和可用性
水平拆分（分表、分库）的缺点：

分片事务一致性难以解决
跨节点JOIN性能差，逻辑会变得复杂
数据扩展难度大，不易维护
在系统设计时应根据业务耦合来确定垂直分库和垂直分表的方案，在数据访问压力不是特别大时应考虑 缓存、读写分离等方法，若数据量很大，或持续增长可考虑水平分库分表，水平拆分所涉及的逻辑比较 复杂，常见的方案有客户端架构和恶代理架构。

分库分表后，ID键如何处理？
分库分表后不能每个表的ID都是从1开始，所以需要一个全局ID，设置全局ID主要有以下几种方法：

UUID：优点：本地生成ID，不需要远程调用；全局唯一不重复。缺点：占用空间大，不适合作为 索引。

数据库自增ID：在分库分表表后使用数据库自增ID，需要一个专门用于生成主键的库，每次服务接 收到请求，先向这个库中插入一条没有意义的数据，获取一个数据库自增的ID，利用这个ID去分库 分表中写数据。优点：简单易实现。缺点：在高并发下存在瓶颈。系统结构如下图


Redis生成ID：优点：不依赖数据库，性能比较好。缺点：引入新的组件会使得系统复杂度增加

Twitter的snowflake算法：是一个64位的long型的ID，其中有1bit是不用的，41bit作为毫秒数， 10bit作为工作机器ID，12bit作为序列号。 1bit：第一个bit默认为0，因为二进制中第一个bit为1的话为负数，但是ID不能为负数. 41bit：表示的是时间戳，单位是毫秒。 10bit：记录工作机器ID，其中5个bit表示机房ID，5个bit表示机器ID。 12bit：用来记录同一毫秒内产生的不同ID。

MySQL的复制原理及流程？如何实现主从复制？
MySQL复制：为保证主服务器和从服务器的数据一致性，在向主服务器插入数据后，从服务器会自动将 主服务器中修改的数据同步过来。

主从复制的原理：

主从复制主要有三个线程：binlog线程，I/O线程，SQL线程。

binlog线程：负责将主服务器上的数据更改写入到二进制日志（Binary log）中。
I/O线程：负责从主服务器上读取二进制日志（Binary log），并写入从服务器的中继日志（Relay log）中。
SQL线程：负责读取中继日志，解析出主服务器中已经执行的数据更改并在从服务器中重放
复制过程如下


Master在每个事务更新数据完成之前，将操作记录写入到binlog中。
Slave从库连接Master主库，并且Master有多少个Slave就会创建多少个binlog dump线程。当 Master节点的binlog发生变化时，binlog dump会通知所有的Slave，并将相应的binlog发送给 Slave。
I/O线程接收到binlog内容后，将其写入到中继日志（Relay log）中。
SQL线程读取中继日志，并在从服务器中重放。
这里补充一个通俗易懂的图。


主从复制的作用：

高可用和故障转移
负载均衡
数据备份
升级测试
了解读写分离吗？

读写分离主要依赖于主从复制，主从复制为读写分离服务。

读写分离的优势：

主服务器负责写，从服务器负责读，缓解了锁的竞争
从服务器可以使用MyISAM，提升查询性能及节约系统开销
增加冗余，提高可用性
————————————————
版权声明：本文为CSDN博主「小李小刘爱编程」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_49182770/article/details/124581473

SQLite数据类型：

事务的4个特性：
1.原子性
2.一致性
3.隔离性
4.持久性

范式：

索引：

ER图：

1、MySQL 中有哪几种锁？
1、表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
2、行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
3、页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
2、MySQL 中有哪些不同的表格？
共有 5 种类型的表格：
1、MyISAM
2、Heap
3、Merge
4、INNODB
5、ISAM
3、简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别

MyISAM：
不支持事务，但是每次查询都是原子的；
支持表级锁，即每次操作是对整个表加锁；
存储表的总行数；
一个 MYISAM 表有三个文件：索引文件、表结构文件、数据文件；
采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。
InnoDb：
支持 ACID 的事务，支持事务的四种隔离级别；
支持行级锁及外键约束：因此可以支持写并发；
不存储总行数：
一个 InnoDb 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为 2G），受操作系统文件大小的限制；
主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；
因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；
最好使用自增主键，防止插入数据时，为维持 B+树结构，文件的大调整。
4、MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？
SQL 标准定义的四个隔离级别为：
1、read uncommited ：读到未提交数据
2、read committed：脏读，不可重复读
3、repeatable read：可重读
4、serializable ：串行事物
5、CHAR 和 VARCHAR 的区别？
1、CHAR 和 VARCHAR 类型在存储和检索方面有所不同
2、CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255 当 CHAR值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。
6、主键和候选键有什么区别？
表格的每一行都由主键唯一标识,一个表只有一个主键。
主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键
引用。
7、myisamchk 是用来做什么的？
它用来压缩 MyISAM 表，这减少了磁盘或内存使用。
MyISAM Static 和 MyISAM Dynamic 有什么区别？
在 MyISAM Static 上的所有字段有固定宽度。动态 MyISAM 表将具有像 TEXT，BLOB 等字段，以适应不同长度的数据类型。
MyISAM Static 在受损情况下更容易恢复。
8、如果一个表有一列定义为 TIMESTAMP，将发生什么？

每当行被更改时，时间戳字段将获取当前时间戳。
列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？
它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。
怎样才能找出最后一次插入时分配了哪个自动增量？
LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值，并且不需要指
定表名称。
9、你怎么看到为表格定义的所有索引？
索引是通过以下方式为表格定义的：
SHOW INDEX FROM ;
10、LIKE 声明中的％和_是什么意思？
％对应于 0 个或更多字符，_只是 LIKE 语句中的一个字符。
如何在 Unix 和 MySQL 时间戳之间进行转换？
UNIX_TIMESTAMP 是从 MySQL 时间戳转换为 Unix 时间戳的命令
FROM_UNIXTIME 是从 Unix 时间戳转换为 MySQL 时间戳的命令
11、列对比运算符是什么？
在 SELECT 语句的列比较中使用=，<>，<=，<，> =，>，<<，>>，<=>，AND，OR 或 LIKE 运算符。
12、BLOB 和 TEXT 有什么区别？
BLOB 是一个二进制对象，可以容纳可变数量的数据。TEXT 是一个不区分大小写的 BLOB。
BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对 TEXT 值不区分大小写。
13、MySQL_fetch_array 和 MySQL_fetch_object 的区别是什么？
以下是 MySQL_fetch_array 和 MySQL_fetch_object 的区别：
MySQL_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。
MySQL_fetch_object – 从数据库返回结果行作为对象。
14、MyISAM 表格将在哪里存储，并且还提供其存储格式？
每个 MyISAM 表格以三种格式存储在磁盘上：
·“.frm”文件存储表定义
·数据文件具有“.MYD”（MYData）扩展名
索引文件具有“.MYI”（MYIndex）扩展名
15、MySQL 如何优化 DISTINCT？
DISTINCT 在所有列上转换为 GROUP BY，并与 ORDER BY 子句结合使用。
SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;
16、如何显示前 50 行？
在 MySQL 中，使用以下代码查询显示前 50 行：
SELECT*FROM
LIMIT 0,50;
17、可以使用多少列创建索引？
任何标准表最多可以创建 16 个索引列。
18、NOW（）和 CURRENT_DATE（）有什么区别？
NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。
CURRENT_DATE（）仅显示当前年份，月份和日期。
19、什么是非标准字符串类型？
1、TINYTEXT
2、TEXT
3、MEDIUMTEXT
4、LONGTEXT
20、什么是通用 SQL 函数？
1、CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。
2、FORMAT(X, D)- 格式化数字 X 到 D 有效数字。
3、CURRDATE(), CURRTIME()- 返回当前日期或时间。
4、NOW（） – 将当前日期和时间作为一个值返回。
5、MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期值中提取给定数据。
6、HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。
7、DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄
8、SUBTIMES（A，B） – 确定两次之间的差异。
9、FROMDAYS（INT） – 将整数天数转换为日期值。
21、MySQL 支持事务吗？

在缺省模式下，MySQL 是 autocommit 模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，MySQL 是不支持事务的。
但是如果你的 MySQL 表类型是使用 InnoDB Tables 或 BDB tables 的话，你的MySQL 就可以使用事务处理,使用 SETAUTOCOMMIT=0 就可以使 MySQL 允许在非 autocommit 模式，在非autocommit 模式下，你必须使用 COMMIT 来提交你的更改，或者用 ROLLBACK来回滚你的更改。
22、MySQL 里记录货币用什么字段类型好

NUMERIC 和 DECIMAL 类型被 MySQL 实现为同样的类型，这在 SQL92 标准允许。
他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。
当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定。
例如：
salary DECIMAL(9,2)
在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。
因此，在这种情况下，能被存储在 salary 列中的值的范围是从-9999999.99 到9999999.99。
23、MySQL 有关权限的表都有哪几个？
MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 MySQL 数据库里，由 MySQL_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv 和 host。
24、列的字符串类型可以是什么？
字符串类型是：
1、SET
2、BLOB
3、ENUM
4、CHAR
5、TEXT
25、MySQL 数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？
1、设计良好的数据库结构，允许部分数据冗余，尽量避免 join 查询，提高效率。
2、选择合适的表字段数据类型和存储引擎，适当的添加索引。
3、MySQL 库主从读写分离。
4、找规律分表，减少单表中的数据量提高查询速度。
5、添加缓存机制，比如 memcached，apc 等。
6、不经常改动的页面，生成静态页面。
7、书写高效率的 SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1,
field_2, field_3 FROM TABLE.


说一说主键索引与唯一索引
主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。
主键索引默认是聚簇索引、唯一索引一般是非聚簇索引。
主键索引不能为空，唯一索引在InnoDB中可以出现多个null。
innoDB的表，优先使用用户自定义主键作为主键、如果用户没有定义主键，则选取一个Unique键作为主键、如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。
主键索引每个表只能有一个，唯一索引可以有多个。
主键的顺序为数据的物理顺序！
为什么要使用自增主键？
首先索引是帮助MySQL高效获取数据的排好序的数据结构。
主键的顺序为数据的物理顺序！
使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，主键的顺序按照数据记录的插入顺序排列，自动有序。当一页写满，就会自动开辟一个新的页。
如果使用非自增主键：由于每次插入主键的值近似于随机，因此每次新记录都要被插到现有索引页的中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。
为什么InnoDB使用B+Tree？
B+Tree.png

核心点：索引是帮助MySQL高效获取数据的排好序的数据结构。
普通二叉树：树的深度不好控制，查找过程中可能需要多次的随机IO！
红黑树：维护红黑树的成本太高！同时树的深度不好控制！
B-Tree：页的大小固定，每个节点包含索引列值和行数据，导致存储量小！相对普通二叉树和红黑树的深度有降低。
Hash：hash冲突问题、仅能满足 “=”，“IN”，不支持范围查询。
B+Tree：非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引、叶子节点包含所有索引字段、叶子节点用指针连接，提高区间访问的性能。
平时如何做MySQL的数据优化的？
避免使用null。可以用0，-1作为默认值替代。
尽可能使用更小的字段！
字段有索引：count(*)≈count(1)>count(字段)>count(主键 id) //字段有索引，count(字段)统计走二级索引，二级索引存储数据比主键索引少，所以count(字段)>count(主键 id)
字段无索引：count(*)≈count(1)>count(主键 id)>count(字段) //字段没有索引count(字段)统计走不了索引，count(主键 id)还可以走主键索引，所以count(主键 id)>count(字段)
优化子查询：尽量处理为小表驱动大表的连接查询。
说一说BLOB与TEXT？
BLOB是一个二进制对象！
TEXT是一个不区分大小写的BLOB！
不能有默认值！
MySQL服务器性能分析，你用过哪些命令？
show [globals] status like '变量名' : 查看会话中的各种信息，也能看到全局的变量。
show profile:分析当前会话中sql语句执行的资源消耗情况的工具，可用于sql调优的测量。默认情况下处于关闭状态，并保存最近15次的运行结果。
show processlist ：显示哪些线程正在运行
MySQL中MyISAM和InnoDB的区别
InnoDB支持事务，MyISAM不支持
InnoDB支持外键，而MyISAM不支持
InnoDB支持MVCC，而MyISAM不支持
InnoDB支持行级锁，而MyISAM不支持
InnoDB不支持全文索引，而MyISAM支持
InnoDB由oracle开发，MyISAM由IBM开发
MySQL中MyISAM和InnoDB的select count(*) 那个更快？
MyISAM内部维护了一个计数器，可以直接调用！
InnoDB中你了解多少日志？
错误日志：记录错误信息
查询日志：记录所有对数据区请求的信息
慢查询日志：查询超出变量 long_query_time 指定时间值的信息。
二进制日志：针对数据库改变的所有操作、中继日志(主从复制，复制过去的就是中继日志，读取中继日志加载数据，保证同步后数据一致)、事务日志（redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作）
InnoDB的行级锁如何加的？了解乐观锁悲观锁么？
在语句后面加 for update
乐观锁：版本控制，每次在数据提交的时候做版本校验。
悲观锁：MySql的悲观锁就是打开事务，当启动事务时，如果事务中的sql语句涉及到索引并用索引进行了条件判断，那么会使用行级锁锁定所要修改的行，否则使用表锁锁住整张表。
简单说：乐观锁就是每次更新的时候判断版本号并加一，悲观锁就是先取锁再访问。
说一说你对视图的了解
视图是一种虚拟的表，具有和物理表相同的功能！
视图通常是有一个表或者多个表的行和列的子集！
视图可以做修改，但是不建议！
可以提高重用性、简化查询：比如要从俩张表获取信息，可以改为从视图中直接获取。
说一说drop、delete、truncate
这三个都表示删除！
delete和truncate只删除表的数据，不删除表结构。drop删除表结构！
速度一般来说：drop > truncate > delete
delete是dml语句，事务提交后才会生效！drop、truncate操作是ddl，直接生效，无事务的说法！
MyISAM，InnoDB的truncate操作会重置auto_increment的值为1。delete如果清空整个表，重启后的auto_increment会从 SELECT 1+MAX(ai_col) FROM t 开始。
MySQL有哪些隔离级别，默认隔离级别是什么？
MySQL隔离级别.png

MySQL默认的隔离级别是可重复读
说一说事务的4个特性
原子性(Atomicity) ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。重点是操作！
一致性(Consistent) ：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性。重点是数据！
隔离性(Isolation) ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。
持久性(Durable) ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。
如何查询sql的执行计划
使用explain + sql语句
MySQL索引的原理是什么？
核心点：索引是帮助MySQL高效获取数据的排好序的数据结构
InnoDB默认的是使用B+Tree
以索引记录20个字节、一行记录1kb计算，一个3层B+Tree可以存放至少500万数据。将第一层与第二层的也放在缓存中，mysql在定位一条数据的时候，只需要一次随机IO就可以找到。mysql的页是连续存放在磁盘上，由于mysql的预读机制，查询一个范围的时候，可以将大量随机IO变为顺序IO，从而大幅度的提高性能！
索引的类型有什么？
普通索引：加速查询
组合（联合）索引：加速查询
唯一索引：建议使用hash，InnoDB中可以有多个null，可以加速查询，列值唯一
主键索引：不能为null，列值唯一，表中只有一个
全文索引：对文本内容分词，进行搜索（只有MyISAM引擎支持）
in和exsits有什么去区别？
核心点：小表驱动大表，即小的数据集驱动大的数据集
in：in里面的数据较小，in优于exists
exists：exists数据量较大，exists优于in。
数据量差不多的时候，这俩个的效率也差不多
VARCHAR（N）实际能存多少数据
如果可以为null，值需要一个字节去区分是不是为null
如果N大于255，需要俩个字节去记录长度
UTF-8一个字符三个字节，实际字符需要除以3
说一说MySQL中InnoDB引擎的行级锁
只有通过索引条件检索数据，才会使用行级锁，否则使用表级锁。
行级锁加在索引上！
MySQL支持的复制类型有哪些？
Statement：每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。可能导致（主从复制）的结果不一致。
Row：不记录sql语句上下文相关信息，仅保存哪条记录被修改。不会出现（主从复制）的结果不一致！所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。
Mixed：折中处理方案，实际上就是Statement与Row的结合。一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog。
说一说MySQL复制的原理以及流程
在Slave 服务器上执行sart slave命令开启主从复制开关，开始进行主从复制。
此时，Slave服务器的IO线程会通过在master上已经授权的复制用户权限请求连接master服务器，并请求从执行binlog日志文件的指定位置（日志文件名和位置就是在配置主从复制服务时执行change master命令指定的）之后开始发送binlog日志内容
Master服务器接收到来自Slave服务器的IO线程的请求后，二进制转储IO线程会根据Slave服务器的IO线程请求的信息分批读取指定binlog日志文件指定位置之后的binlog日志信息，然后返回给Slave端的IO线程。返回的信息中除了binlog日志内容外，还有在master服务器端记录的新的binlog文件名称，以及在新的binlog中的下一个指定更新位置。
当Slave服务器的IO线程获取到Master服务器上IO线程发送的日志内容、日志文件及位置点后，会将binlog日志内容依次写到Slave端自身的Relay Log（即中继日志）文件（MySQL-relay-bin.xxx）的最末端，并将新的binlog文件名和位置记录到master-info文件中，以便下一次读取master端新binlog日志时能告诉Master服务器从新binlog日志的指定文件及位置开始读取新的binlog日志内容
Slave服务器端的SQL线程会实时检测本地Relay Log 中IO线程新增的日志内容，然后及时把Relay LOG 文件中的内容解析成sql语句，并在自身Slave服务器上按解析SQL语句的位置顺序执行应用这样sql语句，并在relay-log.info中记录当前应用中继日志的文件名和位置。
说一说你对数据库范式的理解
核心点
灵活使用，优先范式设计，当范式设计成为系统的性能瓶颈的时候，使用反范式设计。
第一范式
定义：属于第一范式关系的所有属性都不可再分，即数据项不可分。
简单理解：每个列都不可以再拆分。
第二范式
定义：要求数据库表中的每个实例或行必须可以被惟一地区分。
简单理解：不要有部分依赖。该多对多就去做多对多，不要把多对多关系放在一张表
第三范式
定义：每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主键对主键的传递依赖。
简单理解：表关联有个主键就行，不要放除关联主键之外的其他关联表数据。
反范式设计
为了性能和读取效率的考虑而适当的对数据库设计范式的要求进行违反。
允许存在少量的冗余，换句话来说反范式化就是使用空间来换取时间。
说一说表锁与行锁
表锁
每次操作锁住整张表。
开销小（不需要定位到某个元素，只需要定位到表），加锁快；
不会出现死锁；
锁定粒度大，发生锁冲突的概率最高，并发度最低；
一般用在整表数据迁移的场景。
表锁操作方式

手动增加表锁： lock table 表名称 read(write),表名称2 read(write);
查看表上加过的锁 show open tables;
删除表锁 unlock tables;
行锁
每次操作锁住一行数据。
开销大，加锁慢；
会出现死锁；
锁定粒度最小，发生锁冲突的概率最低，并发度高。
InnoDB与MYISAM的最大不同点：InnoDB支持行级锁、支持事务
MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自动给涉及的表加写锁。
InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加锁。但是update、insert、delete操作会加行锁。
行锁操作方式

sql后增加for update来实现行锁。
for update在不走索引的时候会锁表！但是当要修改或者查询的数据不存在的时候，不会锁表，也不会锁定行！
说一说间隙锁
间隙锁，锁的就是两个值之间的空隙。
间隙锁是在可重复读隔离级别下才会生效。
在普通索引列上，不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样；
在普通索引和唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序。
说一说临键锁
行锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。。
这是Innodb在可重复读提交下为了解决幻读问题时引入的锁机制。
说一说读锁与写锁
读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。
什么是非标准字符串类型？
TINYTEXT
TEXT
MEDIUMTEXT
LONGTEXT
说一说MySQL的时间函数
时间函数结果.png

now()（current_timestamp()）函数获得的是语句开始执行时的时间，而sysdate()函数是这个函数执行时候的时间。
CURRENT_DATE：年月日；其他：年月日时分秒
索引列的数量有没有限制？
有限制
默认16个列！
MySQL的sql语句区分大小写么？
不区分，下面一个sql是等价的
SELECT NOW();
select now();
sElEcT nOw();
性能比较：关键字大写>所有语句大写>所有语句小写
说一说left join和left semi join
left join等价于left outer join，可以直接执行。
left semi join是MySQL内部优化的in、exist的方式。
left join将结果集会逐条匹配，left semi join只要存在一个就算匹配上。
执行成功与失败结果.png
说一说union与union all
结果集：union数据不重复，union all数据可能有重复
union：如果查询字段的顺序的第一个字段是聚集索引（或者主键）,UNION的双方就会以merge的方式去重。如果查询字段的顺序非聚集索引，UNION的过程是现将两个结果集合并起来（上文提到的Concatenation），然后再做sort排序去重。
合并结果集，需要去重就用UNION，不需要去重就用UNION ALL，如果两个结果集中没有重复的结果集，就用UNION ALL
mysql如何记录货币
主要使用三种类型：float、double、decimal
类型	大小	范围（有符号）	范围（无符号）	用途
float	4bytes	(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)	0，(1.175 494 351 E-38，3.402 823 466 E+38)	单精度 浮点数值
double	8 bytes	(-1.797 693 134 862 315 7 E+308，-2.225073858507 2014E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)	0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)	双精度 浮点数值
decimal	对decimal(M,D) ，如果M>D，为M+2否则为D+2	依赖于M和D的值	依赖于M和D的值	小数值
什么是通用sql函数
CONCAT(A, B)：连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。
FORMAT(X, D)：将数据内容格式化的，可以将数据格式化为整数或者带几位小数的浮点数（四舍五入）。
CURRDATE(), CURRTIME()：返回当前日期或时间。
NOW（）：将当前日期和时间作为一个值返回。
MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（）：从日期值中提取给定数据。
HOUR（），MINUTE（），SECOND（）：从时间值中提取给定数据。
DATEDIFF（A，B）：确定两个日期之间的差异，通常用于计算年龄
SUBTIMES（A，B）：确定两次之间的差异。
FROMDAYS（INT） – 将整数天数转换为日期值。
mysql有关权限的表都有哪几个？
权限表存放在mysql数据库里，由mysql_install_db脚本初始化。
这些权限表分别user，db，table_priv，columns_priv和host。
MySQL那ACID靠什么保证的？
A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql
C一致性一般由代码层面来保证
I隔离性由MVCC来保证
D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复